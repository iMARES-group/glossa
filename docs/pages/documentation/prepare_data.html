<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Prepare data - GLOSSA – Quarto</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../images/logo_glossa.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-9df1193814cf2dfa54470917b26cda80.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../images/logo_glossa_text.png" alt="GLOSSA logo" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../get_started.html"> 
<span class="menu-text">Get started</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../pages/documentation/index.html"> 
<span class="menu-text">Documentation</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../pages/tutorials_examples/index.html"> 
<span class="menu-text">Tutorials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../news.html"> 
<span class="menu-text">Changelog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../how_to_cite.html"> 
<span class="menu-text">Cite us</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../contact_us.html"> 
<span class="menu-text">Contact us</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-help" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Help</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-help">    
        <li>
    <a class="dropdown-item" href="../../under_construction.html">
 <span class="dropdown-text">Report a bug</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../under_construction.html">
 <span class="dropdown-text">FAQs</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://github.com/iMARES-group/glossa" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#species-occurrence-data" id="toc-species-occurrence-data" class="nav-link active" data-scroll-target="#species-occurrence-data">Species occurrence data</a></li>
  <li><a href="#environmental-data" id="toc-environmental-data" class="nav-link" data-scroll-target="#environmental-data">Environmental data</a></li>
  <li><a href="#raster-timestamp-mapping-optional" id="toc-raster-timestamp-mapping-optional" class="nav-link" data-scroll-target="#raster-timestamp-mapping-optional">Raster timestamp mapping (optional)</a></li>
  <li><a href="#projection-layers-optional-but-likely-your-primary-interest" id="toc-projection-layers-optional-but-likely-your-primary-interest" class="nav-link" data-scroll-target="#projection-layers-optional-but-likely-your-primary-interest">Projection layers (optional, but likely your primary interest)</a></li>
  <li><a href="#study-area-polygon-optional" id="toc-study-area-polygon-optional" class="nav-link" data-scroll-target="#study-area-polygon-optional">Study area polygon (optional)</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/iMARES-group/glossa/edit/main/pages/documentation/prepare_data.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/iMARES-group/glossa/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Preparing your data</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>As with any statistical software or R function, <strong>GLOSSA requires properly formatted input data</strong> to run successfully. This guide walks you through preparing the necessary files: <strong>species occurrence data</strong>, <strong>environmental predictor layers</strong>, and optional <strong>projection layers</strong> and <strong>study area polygons</strong>.</p>
<p>GLOSSA is a modeling tool that depends entirely on user-provided data. It does not make assumptions about data quality, reliability, or sampling design. Therefore, it is the user’s responsibility to ensure that the data is appropriate for species distribution modeling and has gone through any necessary preprocessing outside of GLOSSA.</p>
<blockquote class="blockquote">
<p><a href="https://doi.org/10.5281/zenodo.14223866">Here</a> you can find example files.</p>
</blockquote>
<section id="species-occurrence-data" class="level2">
<h2 class="anchored" data-anchor-id="species-occurrence-data">Species occurrence data</h2>
<p>GLOSSA supports both <strong>presence/absence data</strong> and <strong>presence-only data together with pseudo-absences</strong>. Occurrence records may come from different sources such as survey programs, research studies, fisheries logbooks, satellite tracking, or public data repositories such as the Global Biodiversity Information Facility (<a href="https://www.gbif.org/">GBIF</a>) and the Ocean Biogeographic Information System (<a href="https://obis.org/">OBIS</a>). If the data set includes several data types, GLOSSA treats them in the same way. If any preprocessing step not implemented in GLOSSA is required, it should be done before using the application.</p>
<p>Species occurrence data must be provided in a <strong>tab-separated file</strong> (<code>.tsv</code> or tab-separated file) using the WGS84 coordinate reference system. The file should include the following columns:</p>
<ul>
<li><code>decimalLongitude</code>: Longitude of the occurrence point in decimal degrees.</li>
<li><code>decimalLatitude</code>: Latitude of the occurrence point in decimal degrees.</li>
<li><code>pa</code>: Presence (<code>1</code>) or absence (<code>0</code>) of the species. If this column is missing, GLOSSA will assume all rows represent presences (<code>1</code>, presence-only) and will generate pseudo-absences before the modeling step.</li>
<li><code>timestamp</code>: The time when the occurrence was recorded. This column is optional. If used, GLOSSA will match each occurrence to the environmental data from that specific time period. If omitted, GLOSSA will assume all occurrences occurred at the same time.</li>
</ul>
<p><strong>Example file format</strong>:</p>
<pre class="tsv"><code>decimalLongitude decimalLatitude pa   timestamp
5.42909          43.20937        1    1
-43.05000        49.03000        0    1
-2.52369         47.29234        1    2
34.05400         -26.91300       1    3</code></pre>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Ensure that all occurrence points fall within the study area defined by your environmental data to avoid losing data points due to missing covariate values.</li>
<li>Double-check for formatting errors or missing columns before uploading to avoid processing issues.</li>
<li>You may fit multiple models for different species simultaneously within a session.</li>
<li>If needed, check data quality and preprocess your data to mitigate sampling bias using tools such as <code>CoordinateCleaner</code> (Zizka et al., 2019), <code>OCCUR</code> (Ronquillo et al., 2024), or thinning techniques (e.g.&nbsp;environmental thinning; Moudrý et al., 2024).</li>
</ul>
</div>
</div>
</section>
<section id="environmental-data" class="level2">
<h2 class="anchored" data-anchor-id="environmental-data">Environmental data</h2>
<p>Environmental predictor variables are provided as raster layers in formats like <code>.tif</code>, <code>.tiff</code>, or <code>.nc</code> (NetCDF). All environmental layers should be uploaded as a <strong>ZIP file</strong>, with each variable organized into separate subdirectories. Each subdirectory should contain the raster files corresponding to the different time periods (if applicable).</p>
<p>GLOSSA will automatically extract environmental values at occurrence locations, matching by <code>timestamp</code> if multiple temporal layers are available. Only locations with complete environmental data are used for modeling, removing occurrences with missing predictor values. All rasters must be in the WGS84 coordinate reference system. If layers differ in resolution or extent, GLOSSA will harmonize them by aggregating to the coarsest resolution and adjusting extents accordingly.</p>
<p>Predictors may come, for example, from global databases such as the National Oceanic and Atmospheric Administration (<a href="https://www.noaa.gov/">NOAA</a>), the Inter-Sectoral Impact Model Intercomparison Project (<a href="https://www.isimip.org/">ISIMIP</a>), or <a href="https://www.bio-oracle.org/">Bio-ORACLE</a>, or represent custom variables such as fishing effort (e.g., <a href="https://globalfishingwatch.org/">Global Fishing Watch</a>) or covariates representing sampling bias.</p>
<p>GLOSSA also supports the use of categorical variables in your models. These variables can represent categorical data such as ice cover, habitat classes, or other discrete data. Categorical variables are automatically transformed using one-hot encoding by GLOSSA and the <code>dbarts</code> package, converting them into new binary columns for modeling. To ensure a good fit in the GLOSSA workflow, categorical layers must be properly formatted before uploading.</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Including categorical variables in GLOSSA
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>GLOSSA (<code>&gt;= v1.1.0</code>) now supports including categorical variables in your models, but they must be formatted correctly to ensure a smooth integration.</p>
<ol type="1">
<li>As with continuous variables, categorical layers must be provided as raster files (e.g., <code>.tif</code>, <code>.nc</code>, <code>.asc</code>) where the values are integer IDs that map to specific categories. For example, if representing ice cover, you might define <code>0</code> as “no ice” and <code>1</code> as “ice-covered.”</li>
<li>Rasters must be defined as factors, which typically requires metadata files (e.g., <code>.xml</code>) to enable proper mapping between the integer values and their corresponding categories. If categorical variables are not uploaded as factors, GLOSSA will treat them as continuous variables.</li>
<li>When using categorical layers across time steps or for projections, ensure the categories remain consistent. The set of categories must match or be a subset of those observed in the training data. Avoid attempting to predict on unobserved categories.</li>
</ol>
<p>To include categorical variables in GLOSSA, you need to provide categorical factor rasters. You can create these using functions like <code>terra::as.factor()</code> to convert integer rasters into factor rasters with defined levels and labels:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(terra)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>raster <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="st">"ice_cover.tif"</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>raster <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(raster)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">levels</span>(raster) <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">id =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="at">label =</span> <span class="fu">c</span>(<span class="st">"no"</span>, <span class="st">"yes"</span>))</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="fu">writeRaster</span>(raster, <span class="st">"ice_cover_factor.tif"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When saving your file, the raster metadata is often stored in a separate file (e.g., <code>.xml</code>, <code>.aux.xml</code>). Ensure these metadata files are placed alongside the corresponding raster file in the same directory of the ZIP file before uploading.</p>
<pre class="plaintext"><code>environmental_data.zip
    ├── continuous_variable
    │     └── cont_var.tif
    ├── categorical_variable
    │     ├── cat_var.tif
    │     └── cat_var.tif.aux.xml</code></pre>
</div>
</div>
</div>
<p>Here are some guidelines for preparing your files:</p>
<ul>
<li><strong>Consistent resolution and extent</strong>: Ensure that all raster layers have the <strong>same resolution</strong> and <strong>geographic extent</strong>. GLOSSA will check for mismatches and notify you with warnings or errors:
<ul>
<li>If extents differ, smaller rasters will be extended using <code>NA</code> to match the largest raster.</li>
<li>If resolutions differ, GLOSSA will aggregate to the coarsest resolution using the mean.</li>
</ul></li>
<li><strong>Temporal alignment</strong>: If your occurrence data contains multiple time periods (<code>timestamp</code> column in the occurrence data), the rasters must align with those timestamps. GLOSSA expects the raster files to be <strong>ordered alphabetically</strong> by time. For example, if your occurrence data includes years 1 and 3, you should have raster files for <strong>each</strong> environmental variable for <strong>years 1, 2, and 3</strong> (even if you don’t have occurrence data for year 2). In this case, you can provide a blank or duplicate raster for year 2, but the file must exist to ensure proper indexing for year 3.</li>
</ul>
<p><strong>Example ZIP structure:</strong></p>
<pre class="plaintext"><code>environmental_data.zip
    ├── temperature
    │     ├── temp_1.tif
    │     ├── temp_2.tif
    │     └── temp_3.tif
    ├── salinity
    │     ├── sal_1.tif
    │     ├── sal_2.tif
    │     └── sal_3.tif</code></pre>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Use clear and consistent file names, especially when handling multiple time periods or variables.</li>
<li>Ensure that the number and order of raster layers match the occurrence data timestamps. If more explicit control is needed, you may upload a file specifying the exact time indices (see below).</li>
<li>Carefully check the spatial and temporal resolution of your layers. Both the resolution and the extent of your study area should be appropriate for your research question and the scale/precision of your occurrence data.</li>
<li>Select predictor variables that are meaningful for your species. Do they reflect known habitat preferences?</li>
<li>Check that the predictor variables are available for the whole extent of the study area.</li>
<li>Large raster files may slow down the processing. For testing purposes, consider using lower-resolution rasters or aggregating the cells using the <code>terra::aggregate()</code> function in R</li>
</ul>
</div>
</div>
</section>
<section id="raster-timestamp-mapping-optional" class="level2">
<h2 class="anchored" data-anchor-id="raster-timestamp-mapping-optional">Raster timestamp mapping (optional)</h2>
<p>In GLOSSA’s advanced options, you can upload a <strong>timestamp mapping file</strong> to gain better control over how raster layers are matched to occurrence data time steps. This is especially useful when, your raster layers do not cover a continuous or complete temporal range, you have gaps in the environmental data, the number of rasters do not match the timestamps in the occurrence file.</p>
<p>The mapping file should be a plain text file (<code>.txt</code>) with <strong>one column</strong>, listing the timestamp that corresponds to <strong>each raster layer in the order they appear</strong> in your ZIP file.</p>
<p>By default, GLOSSA assumes that the <strong>first raster</strong> for each environmental variable matches the <strong>first timestamp</strong> in your occurrence data, the second raster matches the second timestamp, and so on. This can cause problems if the raster set includes years not represented in your occurrence data.</p>
<p><strong>Example</strong></p>
<p>Suppose your occurrence data includes records from years <code>2001</code> and <code>2003</code>, but your raster folder includes:</p>
<pre class="plaintext"><code>x_2000.tif
x_2001.tif
x_2002.tif
x_2003.tif</code></pre>
<p>If no timestamp mapping is provided, GLOSSA will incorrectly assume that <code>x_2000.tif</code> corresponds to timestamp <code>2001</code>. To fix this, you can either remove <code>x_2000.tif</code> from the ZIP file and keep only rasters from 2001 onward. Or upload a timestamp mapping file that explicitly defines which raster corresponds to which timestamp.</p>
<p>Another example, if your ZIP includes only <code>x_2001.tif</code> and <code>x_2003.tif</code>, you can provide a mapping file like this (<code>.txt</code>):</p>
<pre class="plaintext"><code>2001
2003</code></pre>
<p>This tells GLOSSA that the first raster corresponds to timestamp <code>2001</code> and that the second raster corresponds to timestamp <code>2003</code>.</p>
<p>Alternatively, as timestamps are used only for indexing, you can relabel your occurrence data. For instance, rename timestamps <code>2001</code> and <code>2003</code> as <code>1</code> and <code>2</code> respectively, and provide just two rasters:</p>
<pre class="plaintext"><code>x_2001.tif
x_2003.tif</code></pre>
<p>No mapping file is then needed. GLOSSA will match occurrence timestamp <code>1</code> to the first raster, and <code>2</code> to the second.</p>
<p><strong>Just remember</strong> that consistency in layer order and timestamp mapping is crucial for accurate environmental matching.</p>
</section>
<section id="projection-layers-optional-but-likely-your-primary-interest" class="level2">
<h2 class="anchored" data-anchor-id="projection-layers-optional-but-likely-your-primary-interest">Projection layers (optional, but likely your primary interest)</h2>
<p>Projection layers allow you to <strong>forecast species distributions</strong> under different environmental conditions, such as future climate scenarios. These layers should follow the exact format as the environmental data, with <strong>identical subdirectory names</strong> and <strong>matching variable names</strong>.</p>
<p>Some guidelines for preparing your files:</p>
<ul>
<li><strong>File order</strong>: Ensure that the files within each subdirectory are <strong>ordered consistently</strong> across variables. The first file of each variable (e.g., temperature, salinity) will be treated as corresponding to the same time period, and GLOSSA will stack and project them together as part of the same time series. That is, in the following example, GLOSSA will make one projection for the <code>temp_projection_1.tif</code> and <code>sal_projection_1.tif</code> scenario, and a different projection for the conditions of <code>temp_projection_2.tif</code> and <code>sal_projection_2.tif</code>.</li>
<li><strong>Multiple scenarios</strong>: If you’re working with multiple independent scenarios (e.g., two different climate models), upload each scenario in a separate <strong>ZIP file</strong>. This way, they won’t be included in the same time series, allowing you to compare scenarios separately during plotting and exporting.</li>
</ul>
<p><strong>Example projection ZIP structure:</strong></p>
<pre class="plaintext"><code>projection_layers.zip
    ├── temperature
    │     ├── temp_projection_1.tif
    │     └── temp_projection_2.tif
    ├── salinity
    │     ├── sal_projection_1.tif
    │     └── sal_projection_2.tif</code></pre>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Ensure that projection layers have the <strong>same resolution</strong>, <strong>geographic extent</strong>, <strong>coordinate reference systems (CRS - WGS84)</strong>, and <strong>variable names</strong> as the environmental layers used during model fitting. This consistency is crucial for accurate forecasting and projections.</li>
<li>If your projections involve different time periods, ensure the raster files are clearly organized and ordered to reflect these periods accurately.</li>
</ul>
</div>
</div>
</section>
<section id="study-area-polygon-optional" class="level2">
<h2 class="anchored" data-anchor-id="study-area-polygon-optional">Study area polygon (optional)</h2>
<p>You can define a <strong>study area polygon</strong> to limit the geographic scope of your analysis. This will crop the environmental layers and filter out occurrence points that fall outside the study area. By default, GLOSSA uses the extent of your environmental rasters to define the study area, fitting the model only with occurrences that have valid values for all predictor variables. It also projects only onto cells covered by all environmental variables.</p>
<p>However, if your rasters cover a larger region than your area of interest or if you have occurrence points outside the region you’d like to filter, you can upload a custom polygon. This allows you to specify the geographic region of interest, and GLOSSA will automatically crop the environmental layers and restrict the analysis to within the polygon boundaries.</p>
<p>The supported formats of this file are:</p>
<ul>
<li><strong>GPKG (GeoPackage)</strong></li>
<li><strong>KML</strong></li>
<li><strong>GeoJSON</strong></li>
</ul>
<p><strong>Example use case:</strong> You might have environmental data for an entire ocean but only want to model species distributions within the Mediterranean Sea. Uploading a Mediterranean Sea polygon will crop the data accordingly.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>If the resolution of your polygon is too coarse, you can apply a buffer to expand or refine it. This buffer option will be explained in the next section of the documentation.</li>
</ul>
</div>
</div>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>By properly formatting your data, you’ll ensure that GLOSSA runs smoothly and provides accurate results. Once your data is ready, move on to the next step: <a href="../../pages/documentation/run_new_analysis.html">Running a new analysis</a>.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<blockquote class="blockquote">
<p>Moudrý, V., Bazzichetto, M., Remelgado, R., Devillers, R., Lenoir, J., Mateo, R. G., … &amp; Šímová, P. (2024). Optimising occurrence data in species distribution models: sample size, positional uncertainty, and sampling bias matter. <em>Ecography, 2024</em>(12), e07294. <a href="https://doi.org/10.1111/ecog.07294" class="uri">https://doi.org/10.1111/ecog.07294</a></p>
</blockquote>
<blockquote class="blockquote">
<p>Ronquillo, C., Stropp, J., &amp; Hortal, J. (2024). OCCUR Shiny application: A user‐friendly guide for curating species occurrence records. <em>Methods in Ecology and Evolution, 15</em>(5), 816-823. <a href="https://doi.org/10.1111/2041-210X.14271" class="uri">https://doi.org/10.1111/2041-210X.14271</a></p>
</blockquote>
<blockquote class="blockquote">
<p>Zizka, A., Silvestro, D., Andermann, T., Azevedo, J., Duarte Ritter, C., Edler, D., … &amp; Antonelli, A. (2019). CoordinateCleaner: Standardized cleaning of occurrence records from biological collection databases. <em>Methods in Ecology and Evolution, 10</em>(5), 744-751. <a href="https://doi.org/10.1111/2041-210X.13152" class="uri">https://doi.org/10.1111/2041-210X.13152</a></p>
</blockquote>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Developed by <a href="https://imares.science/"><img src="images/logo_imares.png" class="img-fluid" alt="iMARES" width="65"></a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/iMARES-group/glossa/edit/main/pages/documentation/prepare_data.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/iMARES-group/glossa/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>